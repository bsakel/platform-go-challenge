package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"platform-go-challenge/graph/model"
	"platform-go-challenge/models"
	"sync"
)

// Userstared is the resolver for the userstared field.
func (r *queryResolver) Userstared(ctx context.Context, userID string) (*model.UserStared, error) {
	// Fetch all user stars for this user
	var userStars []models.UserStar
	if err := r.DB.Where("user_id = ?", userID).Find(&userStars).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch user stars: %w", err)
	}

	// Initialize slices to hold IDs for each asset type
	var audienceIDs []uint
	var chartIDs []uint
	var insightIDs []uint

	// Group asset IDs by type
	for _, star := range userStars {
		switch star.Type {
		case models.AssetTypeAudience:
			audienceIDs = append(audienceIDs, star.AssetID)
		case models.AssetTypeChart:
			chartIDs = append(chartIDs, star.AssetID)
		case models.AssetTypeInsight:
			insightIDs = append(insightIDs, star.AssetID)
		}
	}

	// Fetch all assets concurrently using goroutines
	var audiences []models.Audience
	var charts []models.Chart
	var insights []models.Insight
	var wg sync.WaitGroup
	var audienceErr, chartErr, insightErr error

	// Fetch audiences concurrently
	wg.Add(1)
	go func() {
		defer wg.Done()
		if len(audienceIDs) > 0 {
			if err := r.DB.Where("id IN ?", audienceIDs).Find(&audiences).Error; err != nil {
				audienceErr = fmt.Errorf("failed to fetch audiences: %w", err)
			}
		}
	}()

	// Fetch charts concurrently
	wg.Add(1)
	go func() {
		defer wg.Done()
		if len(chartIDs) > 0 {
			if err := r.DB.Where("id IN ?", chartIDs).Find(&charts).Error; err != nil {
				chartErr = fmt.Errorf("failed to fetch charts: %w", err)
			}
		}
	}()

	// Fetch insights concurrently
	wg.Add(1)
	go func() {
		defer wg.Done()
		if len(insightIDs) > 0 {
			if err := r.DB.Where("id IN ?", insightIDs).Find(&insights).Error; err != nil {
				insightErr = fmt.Errorf("failed to fetch insights: %w", err)
			}
		}
	}()

	// Wait for all goroutines to complete
	wg.Wait()

	// Check for errors
	if audienceErr != nil {
		return nil, audienceErr
	}
	if chartErr != nil {
		return nil, chartErr
	}
	if insightErr != nil {
		return nil, insightErr
	}

	// Convert to pointers for GraphQL response
	gqlAudiences := make([]*models.Audience, len(audiences))
	for i := range audiences {
		gqlAudiences[i] = &audiences[i]
	}

	gqlCharts := make([]*models.Chart, len(charts))
	for i := range charts {
		gqlCharts[i] = &charts[i]
	}

	gqlInsights := make([]*models.Insight, len(insights))
	for i := range insights {
		gqlInsights[i] = &insights[i]
	}

	// Parse userID to int
	var userIDInt int
	if _, err := fmt.Sscanf(userID, "%d", &userIDInt); err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Build and return the UserStared response
	return &model.UserStared{
		Userid:   userIDInt,
		Audience: gqlAudiences,
		Chart:    gqlCharts,
		Insight:  gqlInsights,
	}, nil
}
