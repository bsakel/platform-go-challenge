package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"platform-go-challenge/graph/model"
	"platform-go-challenge/models"
)

// Userstared is the resolver for the userstared field.
func (r *queryResolver) Userstared(ctx context.Context, userID string) (*model.UserStared, error) {
	// Fetch all user stars for this user
	var userStars []models.UserStar
	if err := r.DB.Where("user_id = ?", userID).Find(&userStars).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch user stars: %w", err)
	}

	// Initialize slices to hold IDs for each asset type
	var audienceIDs []uint
	var chartIDs []uint
	var insightIDs []uint

	// Group asset IDs by type
	for _, star := range userStars {
		switch star.Type {
		case "Audience":
			audienceIDs = append(audienceIDs, star.AssetID)
		case "Chart":
			chartIDs = append(chartIDs, star.AssetID)
		case "Insight":
			insightIDs = append(insightIDs, star.AssetID)
		}
	}

	// Fetch all audiences
	var audiences []models.Audience
	if len(audienceIDs) > 0 {
		if err := r.DB.Where("id IN ?", audienceIDs).Find(&audiences).Error; err != nil {
			return nil, fmt.Errorf("failed to fetch audiences: %w", err)
		}
	}

	// Fetch all charts
	var charts []models.Chart
	if len(chartIDs) > 0 {
		if err := r.DB.Where("id IN ?", chartIDs).Find(&charts).Error; err != nil {
			return nil, fmt.Errorf("failed to fetch charts: %w", err)
		}
	}

	// Fetch all insights
	var insights []models.Insight
	if len(insightIDs) > 0 {
		if err := r.DB.Where("id IN ?", insightIDs).Find(&insights).Error; err != nil {
			return nil, fmt.Errorf("failed to fetch insights: %w", err)
		}
	}

	// Convert to pointers for GraphQL response
	gqlAudiences := make([]*models.Audience, len(audiences))
	for i := range audiences {
		gqlAudiences[i] = &audiences[i]
	}

	gqlCharts := make([]*models.Chart, len(charts))
	for i := range charts {
		gqlCharts[i] = &charts[i]
	}

	gqlInsights := make([]*models.Insight, len(insights))
	for i := range insights {
		gqlInsights[i] = &insights[i]
	}

	// Parse userID to int
	var userIDInt int
	if _, err := fmt.Sscanf(userID, "%d", &userIDInt); err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Build and return the UserStared response
	return &model.UserStared{
		Userid:   userIDInt,
		Audience: gqlAudiences,
		Chart:    gqlCharts,
		Insight:  gqlInsights,
	}, nil
}
